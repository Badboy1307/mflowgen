#!/usr/bin/env python
#=========================================================================
# lab1-sim [options]
#=========================================================================
#
#  -h --help           Display this message
#
#  --impl              {fl,cl-fixed,cl-var,cl-nstage,rtl-scycle,rtl-fixed,rtl-var,rtl-nstage}
#  --nstages           Number of pipeline stages for nstage models
#  --input <dataset>   {small,large,lomask,himask,lohimask,sparse}
#  --trace             Display line tracing
#  --stats             Display statistics
#  --translate         Translate RTL model to Verilog
#  --dump-vcd          Dump VCD to imul-<impl>-<input>.vcd
#
# Author : Christopher Batten
# Date   : February 5, 2015
#

from __future__ import print_function

# Hack to add project root to python path

import os
import sys

sim_dir = os.path.dirname( os.path.abspath( __file__ ) )
while sim_dir:
  if os.path.exists( sim_dir + os.path.sep + ".pymtl-python-path" ):
    sys.path.insert(0,sim_dir)
    break
  sim_dir = os.path.dirname(sim_dir)

import argparse
import re

from pymtl             import *

from IntMulFL          import IntMulFL
from IntMulFixedLatCL  import IntMulFixedLatCL
from IntMulVarLatCL    import IntMulVarLatCL
from IntMulNstageCL    import IntMulNstageCL
from IntMulScycleRTL   import IntMulScycleRTL
from IntMulFixedLatRTL import IntMulFixedLatRTL
from IntMulVarLatRTL   import IntMulVarLatRTL
from IntMulNstageRTL   import IntMulNstageRTL

from test.IntMulFL_test import TestHarness
from test.IntMulFL_test import random_small_msgs, random_large_msgs
from test.IntMulFL_test import random_lomask_msgs, random_himask_msgs
from test.IntMulFL_test import random_lohimask_msgs, random_sparse_msgs

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--impl", default="fl",
    choices=[
      "fl",
      "cl-fixed","cl-var","cl-nstage",
      "rtl-scycle","rtl-fixed","rtl-var","rtl-nstage",
    ] )

  p.add_argument( "--nstages", default=2 )

  p.add_argument( "--input", default="small",
    choices=["small","large","lomask","himask","lohimask","sparse"] )

  p.add_argument( "--trace",     action="store_true" )
  p.add_argument( "--stats",     action="store_true" )
  p.add_argument( "--translate", action="store_true" )
  p.add_argument( "--dump-vcd",  action="store_true" )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------

def main():
  opts = parse_cmdline()

  # Create the input pattern

  inputs  = None

  if   opts.input == "small":    inputs = random_small_msgs
  elif opts.input == "large":    inputs = random_large_msgs
  elif opts.input == "lomask":   inputs = random_lomask_msgs
  elif opts.input == "himask":   inputs = random_himask_msgs
  elif opts.input == "lohimask": inputs = random_lohimask_msgs
  elif opts.input == "sparse":   inputs = random_sparse_msgs

  ninputs = len(inputs[::2])

  # Determine which model to use in the simulator

  model_impl_dict = {
    "fl"        : IntMulFL,
    "cl-fixed"  : IntMulFixedLatCL,
    "cl-var"    : IntMulVarLatCL,
    "cl-nstage" : IntMulNstageCL,
    "rtl-scycle": IntMulScycleRTL,
    "rtl-fixed" : IntMulFixedLatRTL,
    "rtl-var"   : IntMulVarLatRTL,
    "rtl-nstage": IntMulNstageRTL,
  }

  # Check if translation is valid

  if opts.translate and not opts.impl.startswith("rtl"):
    print("\n ERROR: --translate only works with RTL models \n")
    exit(1)

  # Create VCD filename

  dump_vcd = ""
  if opts.dump_vcd:
    if opts.impl.endswith("nstage"):
      dump_vcd = "imul-rtl-{}stage-{}.vcd" \
        .format( int(opts.nstages), opts.input )
    else:
      dump_vcd = "imul-{}-{}.vcd".format( opts.impl, opts.input )

  # Parameters

  params = {}
  if opts.impl.endswith("nstage"):
    params = { "nstages" : int(opts.nstages) }

  # Create test harness (we can reuse the harness from unit testing)

  th = TestHarness( model_impl_dict[ opts.impl ]( **params ),
                    inputs[::2], inputs[1::2], 0, 0,
                    dump_vcd, opts.translate )

  # Setup the test harness

  th.vcd_file = dump_vcd
  th.elaborate()

  # Create a simulator

  sim = SimulationTool( th )

  # Reset test harness

  sim.reset()

  # Run simulation

  while not th.done() and sim.ncycles < 5000:

    if opts.trace:
      sim.print_line_trace()

    sim.cycle()

  # Force a test failure if we timed out

  assert sim.ncycles < 5000

  # Extra ticks to make VCD easier to read

  sim.cycle()
  sim.cycle()
  sim.cycle()

  # Display statistics

  if opts.stats:
    print( "num_cycles         = {}".format( sim.ncycles ) )
    print( "num_cycles_per_mul = {:1.2f}".format( sim.ncycles/(1.0*ninputs) ) )

main()

