#!/usr/bin/env python
#=========================================================================
# isa-sim [options] <elf-binary>
#=========================================================================
#
#  -h --help           Display this message
#
#  --host              Test HostButterfree instead of Butterfree
#  --trace             Display line tracing
#  --limit             Set max number of "steps", default=10000
#
#  <elf-binary>        TinyRV2 elf binary file
#
# Author : Shunning Jiang, Christopher Batten
# Date   : Oct 2, 2016

from __future__ import print_function

# Hack to add project root to python path

import os
import sys

sim_dir = os.path.dirname( os.path.abspath( __file__ ) )
while sim_dir:
  if os.path.exists( sim_dir + os.path.sep + ".pymtl-python-path" ):
    sys.path.insert(0,sim_dir)
    break
  sim_dir = os.path.dirname(sim_dir)

import argparse
import re
import random

random.seed(0xdeadbeef)

from pymtl      import *
from pclib.ifcs import InValRdyBundle, OutValRdyBundle

# Use BRGTC2 special message types

from ifcs import MemMsg
from test import TestMemory

from proc.SparseMemoryImage import SparseMemoryImage
from proc.tinyrv2_encoding  import assemble
from proc import elf

from CompButterfree.test.Butterfree_harness import TestHarness
from CompButterfree.Butterfree import Butterfree
from CompButterfree.HostButterfree import HostButterfree


#=========================================================================
# Command line processing
#=========================================================================

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",               action="store_true"    )

  # Additional commane line arguments for the simulator

  p.add_argument( "--host",                 action="store_true"    )
  p.add_argument( "--trace",                action="store_true"    )
  p.add_argument( "--limit", default=10000, type=int               )

  p.add_argument( "elf_file" )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#=========================================================================
# Main
#=========================================================================

def main():

  opts = parse_cmdline()

  #-----------------------------------------------------------------------
  # Load the elf file and we don't need hacky binary rewriting anymore!
  #-----------------------------------------------------------------------

  # Open elf binary

  mem_image = None
  with open(opts.elf_file,'rb') as file_obj:
    mem_image = elf.elf_reader( file_obj )

  #-----------------------------------------------------------------------
  # Setup simulator
  #-----------------------------------------------------------------------

  num_cores       = 4
  cacheline_nbits = 128

  # Create test harness and elaborate

  if opts.host:
    hwshim_and_dut = HostButterfree( asynch_bitwidth )
    model          = SwShim( Butterfree(), hwshim_and_dut, asynch_bitwidth,
                                           dump_vcd, test_verilog )
    # Set explicit name
    model.explicit_modulename = model.__class__.__name__
  else:
    model = Butterfree()

  th = TestHarness( model, dump_vcd, test_verilog, num_cores, cacheline_nbits,
                    0, 0, 0, 0 ) # TODO add mem_stall_prob, mem_latency as command line option

  th.elaborate()

  # Load the program into the th and the startup message

  th.load_ctrlreg( "asm" )
  th.load_asm( mem_image )

  assert False

  # Create a simulator using the simulation tool

  sim = SimulationTool( th )

  # We are always ready to accept a proc2mngr message

  th.proc2mngr.rdy.value = 1

  #-----------------------------------------------------------------------
  # Run the simulation
  #-----------------------------------------------------------------------

  if opts.trace:
    print()

  count = 0

  # Storage for extra three messages on failure

  app_fail_xtra       = False
  app_fail_xtra_count = 0
  app_fail_xtra_msgs  = [ None, None, None ]

  commit_inst = [0]*4

  # Storage for print

  app_print           = False
  app_print_type      = None  # 0: int, 1: char, 2: string

  sim.reset()
  while count < opts.limit:

    # Generate line trace

    if opts.trace:
      sim.print_line_trace()

    # Check the proc2mngr interface

    if th.proc2mngr.val:

      msg_type = th.proc2mngr.msg[16:32]
      msg_xtra = th.proc2mngr.msg[ 0:16]

      # First we check if we are gathering app_fail_xtra_msgs

      if app_fail_xtra:
        app_fail_xtra_msgs[ app_fail_xtra_count ] = th.proc2mngr.msg[:]
        app_fail_xtra_count += 1
        if app_fail_xtra_count == 3:
          print( "" )
          print( "  [ FAILED ] dest[{0}] != ref[{0}] ({1} != {2})" \
                  .format( int(app_fail_xtra_msgs[0]),
                           int(app_fail_xtra_msgs[1]),
                           int(app_fail_xtra_msgs[2]) ) )
          print( "" )
          exit(1)

      # Then we check if we are doing a print

      elif app_print:

        # Print int

        if app_print_type == 0:
          print( th.proc2mngr.msg[:].uint(), end='' )
          app_print = False

        if app_print_type == 1:
          print( chr(th.proc2mngr.msg[:].uint()), end='' )
          app_print = False

        if app_print_type == 2:
          char_as_num = th.proc2mngr.msg[:].uint()
          if char_as_num > 0:
            print( chr(char_as_num), end='' )
          else:
            app_print = False

      # Message is from an assembly test

      elif msg_type == 0:

        if msg_xtra == 0:
          print( "" )
          print( "  [ passed ]" )
          print( "" )
          break

        else:
          print( "" )
          print( "  [ FAILED ] error on line {}".format(msg_xtra.uint()) )
          print( "" )
          exit(1)

      # Message is from a bmark

      elif msg_type == 1:

        if msg_xtra == 0:
          break
        else:
          exit( msg_xtra.uint() )

      # Message is from a bmark

      elif msg_type == 2:

        if msg_xtra == 0:
          print( "" )
          print( "  [ passed ]" )
          print( "" )
          print("In stats_en region:")
          print(  "  total_committed_inst   = {}".format( reduce(lambda x,y:x+y, commit_inst) ))
          if opts.mcore:
            print( "" )
            for i in xrange(4):
              print("  core{}_committed_inst   = {}".format( i, commit_inst[i] ))
          break

        else:
          app_fail_xtra = True

      # Message is from print

      elif msg_type == 3:
        app_print = True
        app_print_type = msg_xtra
        if app_print_type not in [0,1,2]:
          print("ERROR: received unrecognized app print type!")
          exit(1)

    # Tick the simulator

    sim.cycle()

  #-----------------------------------------------------------------------
  # Post processing
  #-----------------------------------------------------------------------

  # Force a test failure if we timed out

  if count >= opts.limit:
    print("""
   ERROR: Exceeded maximum number of 'steps' ({}). Your
   application might be in an infinite loop, or you need to use the
   --limit command line option to increase the limit.
    """.format(opts.limit))
    exit(1)

  exit(0)

main()

