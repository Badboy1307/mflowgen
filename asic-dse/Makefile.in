#=========================================================================
# Makefile
#=========================================================================
# This generated Makefile chains together the asic flow steps for this
# design according to the design's configuration file. For each asic flow
# step, a make target is generated that contains the commands specified in
# the step's configuration file.
#
# Extra commonly useful targets are also provided:
#
# - all     : Execute all steps
# - clean   : Clean up junk
# - debug-* : Bring up debug view for Innovus targets
# - run-*   : Run command with Makefile variables available
# - print-* : Print any Makefile variable
# - list    : List all configured steps, their short names, and other
#             useful targets
#

#-------------------------------------------------------------------------
# Front matter
#-------------------------------------------------------------------------

.PHONY: default

default: all

# Disable built-in rules

.SUFFIXES:

#-------------------------------------------------------------------------
# Generated variables from configuration
#-------------------------------------------------------------------------

include setup-flow.mk
include Makefrag

#-------------------------------------------------------------------------
# Directories
#-------------------------------------------------------------------------

# Base directory relative to the build directory. The base directory has
# the top-level steps directory, the design-flow directory, etc.

export relative_base_dir := ..

# Absolute base directory, which is marked as the base directory because
# it has the base directory marker file in it. This small shell script
# searches up the directory hierarchy until it finds the marker file. Then
# it labels that directory as the absolute base directory.

export base_dir_marker   := .TOP
export absolute_base_dir := $(shell \
  x=$${PWD};                        \
  while [ "$$x" != "/" ]; do        \
    x=$$(dirname "$$x");            \
    find "$$x" -maxdepth 1 -name $(base_dir_marker) | xargs -I {} dirname {}; \
  done;)

# Master steps directory in the base directory with all possible steps

export master_steps_dir = steps

# Master directory in the base directory with all assembled flows

export master_flows_dir = assembled-flows

# Build directories

export flow_dir       = flow
export plugins_dir    = plugins

export logs_dir       = logs
export reports_dir    = reports
export results_dir    = results

export handoffs_dir   = handoffs
export timestamps_dir = timestamps

#-------------------------------------------------------------------------
# Step management
#-------------------------------------------------------------------------
# Set up VPATH
#
# The VPATH variable is a list of directories to be searched for missing
# prerequisites.
#
# VPATH can be cleverly used to abstract the make tool's dependency
# tracking into "steps" that are easier for the user to understand and
# manipulate than the actual detailed Makefile dependencies. The interface
# is a list of flow steps (i.e., PHONY target files) in $(VPATH).

export VPATH = vpath

junk += $(VPATH)

# list
#
# Useful target that lists all configured steps and their short names. The
# abbreviated versions can be defined in each step's configuration file
# and should be defined as a variable called "abbr.name_of_the_step".
#
# The output will look similar to this:
#
# - dc-synthesis  : synth
# - innovus-init  : init
# - innovus-place : place
# - ...
#

list:
	@echo "--------------------------------------------------------------------------"
	@echo "Available steps targets"
	@echo "--------------------------------------------------------------------------"
	@echo
	@printf                          "%s %-20s   %s\n" ' ' "(Long Name)" "(Short Name)"
	@echo
	@$(foreach step, $(steps),printf "%s %-20s : %s\n" '-'  $(step)     $(abbr.$(step));)
	@echo
	@echo "Other useful targets"
	@echo
	@echo "- seed     : Creates all build directories and seeds the flow steps"
	@echo "- runtimes : Use timestamps to print runtimes for each executed step"
	@echo

# runtimes
#
# Useful target that prints the runtimes for all steps given the
# timestamps for each step (e.g., innovus-place.start, innovus-place.end).
#
# Notes:
#
# - Using "date -f" reads and prints the date in the given file
# - Using "date +%s" formats into seconds since 1970-01-01 00:00:00 UTC
# - The "... 2>/dev/null || echo 0" returns "0" if the file does not exist
# - All bash variables need to be double escaped with $$myvariable
# - This sed command can be added to blank out zero-value printouts
#       sed "s/ 0 hr/     /; s/ 0 min/      /"
# - The total runtime is aggregated across all steps to compute the total.
#   This number might be different compared to subtracting the first/last
#   timestamps because the user might have paused between steps.

runtimes:
	@echo "--------------------------------------------------------------------------"
	@echo "Runtimes"
	@echo "--------------------------------------------------------------------------"
	@(tot_secs=0; \
    $(foreach step, $(steps), \
      end=$(shell date -f $(timestamps_dir)/$(step).end +%s 2>/dev/null || echo 0); \
      start=$(shell date -f $(timestamps_dir)/$(step).start +%s 2>/dev/null || echo 0); \
      step_secs=$$(( $$end - $$start )); \
      tot_secs=$$(($$tot_secs + $$step_secs)); \
      h=$$(( $$step_secs / 3600      )); \
      m=$$(( $$step_secs % 3600 / 60 )); \
      s=$$(( $$step_secs % 60        )); \
      printf '%-20s -- %2d hr %2d min %2d sec\n' $(step) $$h $$m $$s | \
        sed "s/ 0 hr/     /; s/ 0 min/      /";) \
    echo "--------------------------------------------------------------------------"; \
    h=$$(( $$tot_secs / 3600      )); \
    m=$$(( $$tot_secs % 3600 / 60 )); \
    s=$$(( $$tot_secs % 60        )); \
    printf '%-20s -- %2d hr %2d min %2d sec\n' "Total" $$h $$m $$s; )

#-------------------------------------------------------------------------
# Seeding the build directory
#-------------------------------------------------------------------------
# The "seed" target prepares the directory structure and assembles the
# "steps" directory with all of the configured asic flow steps for this
# design according to the configuration file. It also pulls all of the
# design-specific plugins into the "plugins" directory.

seed:
# Generate all asic flow directories
	@mkdir -p $(VPATH) $(flow_dir) $(plugins_dir)
	@mkdir -p $(logs_dir) $(reports_dir) $(results_dir)
	@mkdir -p $(handoffs_dir) $(timestamps_dir)
# Seed links to the master steps into the flow directory
	@(cd $(flow_dir); \
    $(foreach x, $(steps), \
      ln -sf ../../$(master_steps_dir)/$x .;))
# Pull design-specific plugins into the plugins directory
	@(cd $(plugins_dir) && \
    ln -sf ../../$(master_flows_dir)/$(design_flow)/plugins/* .)
# Mark this step done
	@touch $(VPATH)/$@

junk += $(flow_dir) $(plugins_dir)
junk += $(logs_dir) $(reports_dir) $(results_dir)
junk += $(handoffs_dir) $(timestamps_dir)

#-------------------------------------------------------------------------
# Rules template for each step
#-------------------------------------------------------------------------
# This section defines the rules template used to generate the target for
# each asic flow step and "chain together" dependent steps.
#
# The minimum requirement to implement an asic flow step is to create a
# directory called (name of the step) in the master steps directory which
# contains the file "configure.mk", and this file must specify the
# variable "commands.(name of the step)" specifying how to run the step.
#
# For example, if the step name is "myflowstep", then the configure.mk can
# specify:
#
#     commands.myflowstep = echo "Running myflowstep"
#
# The build system uses the following template to include the
# "configure.mk" for the step and then essentially just tells the step to
# run itself by calling the specified command. The template also collects
# handoffs from each of the dependency steps, collects timestamps for
# pretty printing later, and handles misc support functions.

# step_template
#
# - $(1): Name of the step (e.g., "dc-synthesis")
#
# Additional features
#
# - ascii.myflowstep: (optional) This hook can be defined in the step
#                                configure.mk to print a pretty
#                                banner before executing the step,
#                                which is visible as text flies by.

define step_template

# Generate variables for this step

flow_dir.$(1)    = $(flow_dir)/$(1)
plugins_dir.$(1) = $(plugins_dir)/$(1)

logs_dir.$(1)    = $(logs_dir)/$(1)
reports_dir.$(1) = $(reports_dir)/$(1)
results_dir.$(1) = $(results_dir)/$(1)

collect_dir.$(1) = $(handoffs_dir)/$(1)-collect
handoff_dir.$(1) = $(handoffs_dir)/$(1)-handoff

# Include the step makefile fragment

include $$(relative_base_dir)/$$(master_steps_dir)/$(1)/configure.mk

# Primary command target for this step

$(1): $$(dependencies.$(1))
# Collect handoffs from the dependencies
	@rm -rf ./$$(collect_dir.$(1))
	@mkdir -p $$(collect_dir.$(1))
	@(cd $$(collect_dir.$(1)); \
  $$(foreach dep, $$(dependencies.$(1)), \
    $$(foreach file, $$(wildcard $$(handoff_dir.$$(dep))/*), \
      ln -sf ../../$$(file);)))
# Execute the step
	@date > $$(timestamps_dir)/$(1).start
ifdef ascii.$(1)
	$$(ascii.$(1))
endif
	$$(commands.$(1))
	@date > $$(timestamps_dir)/$(1).end
	@touch $(VPATH)/$(1)

# Alias short name target for this step

ifdef abbr.$(1)
$$(abbr.$(1)): $(1)
endif

endef

#-------------------------------------------------------------------------
# Generate targets for all steps
#-------------------------------------------------------------------------

$(foreach step, $(steps), \
  $(eval $(call step_template,$(step))))

.PHONY: all

all: $(dependencies.all)

#-------------------------------------------------------------------------
# Misc
#-------------------------------------------------------------------------

.PHONY: clean

clean:
	rm -rf $(junk)

# print-%
#
# This target makes it easier to debug Makefile rules by allowing you to
# print any variable. For example, "make print-junk" prints the value of
# the junk variable.

print-% :
	@echo $* = $($*)

# run-%
#
# Generic target to execute commands with environment variables set from
# the Makefile.
#
# Note that one particularly useful target is "make run-bash", which gives
# you a new shell with all of the exported environment variables from the
# Makefile available to use.

run-%:
	$*

# Colors for printouts

echo_green   = '\033[92m'
echo_nocolor = '\033[0m'

